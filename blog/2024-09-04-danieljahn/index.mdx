---
slug: five-way-to-use-fused
title: "Five ways to use Fused"
authors: [daniel]
tags: [sylverra]
unlisted: true
# image:
hide_table_of_contents: false
keywords: [sylverra]
---



If you've ever worked with geospatial data, you've likely quickly run into the need to scale your workflows. Given its broad coverage of Earth’s surface, geospatial data tend to be large. Global organisations frequently make datasets publicly available. As an example, the recently released ERA5 climate reanalysis dataset makes 6PB of data freely available.

However, scalable data processing is notoriously challenging and the added complexities of geospatial data can make this task overwhelmingly difficult.

## Fused
Fuses promises to solve this problem. It offers a serverless engine and a toolkit built specifically for geospatial applications.

Like many others, I've been excited about Fused ever since its initial release. After playing around with it, I was impressed. Fused is unbelievably fast. It's easy to use. it provides a host of integrations and ready-to-use components.

Fused is a powerful and versatile tool that can do nearly anything with just Python.

This is its strength, but can make it challenging to frame amidst other tools in the data stack. It's simple to walk away wondering: what, concretely, can Fused do for me?

Here are five concrete ways you can use Fused today.

Github for geospatial UDFs
One use-case of Fused that is immediately visible is its function as a repository of reusable geospatial functions.

Want to find out wildfire ignition types? Quickly get publicly available Sentinel data? Calculate isochrones given a location? You don’t need to write any of this (even today) – all this functionality is already written for you.

Unlike with Github, where you need to first get the code to even work, with Fused, you see the results of any UDF at the click of a button.

As Fused grows, so will its library of UDFs. Given that UDFs are open-source, the community that develops around Fused could be an invaluable resource in and of itself.




## Easy-to-use & faster Dask
The core of Fused is its serverless execution environment. To quote the Fused docs:
“if Python could run on any size datasets and distributed compute was fun.”

I'm a big fan and frequent user of Dask. But to use it effectively one needs to set up the necessary infrastructure and know how to use its APIs and diagnose performance problems.

Fused abstracts most of that away entirely. Simply write your function, decorate it with @fused.udf and run your function over the whole globe.

Fused also solves a common difficulty around serverless computing – the developer experience. Its workbench makes it easy to debug your code and at any point visualize its results on a map.




Multi-platform Snowpark
Snowpark provides a serverless computational layer on top of Snowflake, a popular data platform.

With its quickly growing list of integrations (getting data in and out) Fused is becoming a powerful glue layer for all of geospatial.




Whether you want to process and stream rasters on S3 into QGIS, display an interactive map of Overture data in a Notion document, or serve geospatial data through an HTTP endpoint, Fused provides the scaffolding necessary to make it easy.

Mapbox on steroids
I'll admit, this one is a bit of a tongue-in-cheek. Mapbox is a powerful platform and Fused is not on a mission to replace it.

However, it does get the point across: Fused can power a web map that obtains data from any source and processes them data on-the-fly as the user pans the map. With its caching layer, the user can get the results of previously-computed locations almost instantaneously.

And since Fused automatically serves both raster and vector tiles for any UDF, it can also be used with Mapbox GL JS.

[Mapbox GL JS example here?]

Geospatial-first IDE
Of the five, this is the most aspirational usecase. It's also potentially the most impactful.

Fused provides the Workbench, a great web-based IDE. Working with it started changing how I think of developing geospatial applications.



Today, there are two worlds. On one side, the software engineer uses test-driven-development to develop well-designed code in quick iterations. On the other side, the data scientist develops code directly against real data using notebooks and visualizations.

Fused can bring these worlds together. Simply annotating your function as @fused.udf gives you the ability to immediately visualize the results with real data, over any geographic region. Fused Workbench does this, but you equally develop in VSCode switch to QGIS to immediately inspect the results.

By developing your code as a web of stateless UDFs and utilizing @fused.cache, you gain the ability to develop automatically cached pipelines whose results can be inspected in tools like Felt or served with an HTTP endpoint without any added work.

Often the greatest cost of data pipelines is developer time. Fused has the potential to tighten the development feedback loop and catch errors early, reducing the time needed to develop robust data pipelines.
